# Ridez

[![python](https://img.shields.io/badge/Python-3.12-3776AB.svg?style=flat&logo=python&logoColor=white)](https://www.python.org)

> [!IMPORTANT]
> Not to be used for commercial/public use. As of now, this is only used for personal/business related and will be privated once finished.

## Deployment

The following are provided for ease of deployment:

1. Docker ready (Dockerfile, docker compose)
2. Fixtures.
   - This can be regenerated by running `python scripts/generate_fixtures.py`. Feel free to change the parameters in the file (i.e number of rides, users, etc)

This app also only uses sqlite for development purposes only. If needed, feel free to add another service in docker compose for database. Take note that the django app itself it not configured to connect to an external database.

The default debug server of Django is used for both docker and native deployments.

### Prerequisites

1. Python >= 3.12
2. Create a `.env` file. This can be used in both Docker and Native deployment.
   - `DEBUG`
     - As per django docs, set this to `True` to provide detailed tracebacks and env info during development.
     - Set this to `True` to enable [**Django Debug Toolbar**](https://django-debug-toolbar.readthedocs.io/en/latest/).
   - `LOG_LEVEL`
     - Level of logs to be displayed.
     - Choices: `[DEBUG, INFO, WARN, ERROR]`
   - `PORT`
     - The port to be exposed / deployed.

### Docker

1. Run `docker compose up` / `docker compose up -d` to automatically build and run the app. The dockerfile is configured such that it automatically migrates and runs the app after the container is up. If the file `fixtures.json` is present, then it would automatically be loaded upon container startup.
2. Even though this is just a developer test, for proper security practice, manually create a superuser for an admin account.

    ```sh
    docker compose exec backend python manage.py createsuperuser 
    ```

    You will be asked to enter the ff details: username, email address, phone number, role *(admin, driver, rider)*, and password.

### Native

1. Setup your python environment, refer to `Developers > Developer environment` section below.
2. Run `./start.sh/`. Similar to the Docker route, this will automatically migrate, load fixtures, and run the server with the default port (8000).

## Developers

### Development environment

1. Create and activate a virtual environment of a supported python version with your tool of choice (e.g pyenv, virtualenv).
2. Install the project dependencies:

    ```sh
    make install-dev
    ```

### Updating requirements

1. If needed, add new optional dependency group/s in `pyproject.toml` (e.g. `optional-dependencies.{group}`)
2. Update/introduce dependencies in `requirements/{group}.in`.
3. Generate new pinned requirements files:

    ```sh
    make update-reqs
    ```

4. Sync dependencies:

    ```sh
    make install-dev
    ```

5. Commit changes.

## Bonus: SQL Monthly Metrics

Breaking down this requirement, here is the general idea on how to fetch the count of rides of each driver that reached for more than an hour *(using PostgreSQL functions, I am not that familiar with SQLite functions)*:

1. Fetch a temporary result set (CTE) to get the pickup and dropoff times of the ride and ride events. This result set will contain:
    - ride id
    - driver id,
    - pickup time
    - drop off time
2. Using the data from that dataset, select the ff data:
    - Month - use date_trunc
    - Driver - concat the first name and second name
    - Count - using Count(*), this will work as long as the filter and group in the next steps are correct.
3. Filter the results of the table where:
    - dropoff time - pickup time > interval '1 hour'
4. Group the results by month, and driver, so that the count can be grouped by these.
5. Order the results by month, then driver.

Sample untested SQL that is references the tables of this app:

```SQL
WITH ride_times AS (
    SELECT
        ride.id_ride,
        ride.id_driver,
        MIN(CASE WHEN event.description ILIKE '%pickup%' THEN event.created_at END) AS pickup_time,
        MIN(CASE WHEN event.description ILIKE '%dropoff%' THEN event.created_at END) AS pickup_time
    FROM rides_ride ride
    INNER JOIN rides_rideevent event ON event.id_ride == ride.id_ride
    GROUP BY ride.id_ride, ride.id_driver
),
SELECT
    DATE_TRUNC('month', times.dropoff_time) AS Month,
    CONCAT(user.first_name, ' ', user.last_name) AS Driver
    COUNT(*) AS 'Count of trips > 1 hr'
FROM ride_times times
INNER JOIN rides_user user ON user.id_user == times.id_driver
WHERE (times.dropoff_time - times.pickup_time) > interval '1 hour'
GROUP BY Month, Driver
ORDER BY Month, Driver
```
